依赖资源的装载
	一次只装载一个资源的情况下，
		依赖资源总是在父资源等待的状态下
依赖资源的设置方案
	1.parse也做成协程，装载成为协程的一个片段
	2.资源类包装，抽象，加依赖。Asset

.可写目录 or DOUBILITY_HOME 路径 下的分立文件目录 .root
.streamingAssets中的压缩包。
.可写目录下的数据包.

.unity命令行方式
	.从美术数据生成执行数据,
		生成模型数据
		生成纹理数据
		打包核心数据
		核心数据中的shader,需要一个shader名与文件名的对照表.
	.上载svn
	.发布时可以用参数控制，是否打包数据。
.http方式的服务器。下载可以启用ftp方式。
.windows版本直接使用DOUBILITY_HOME环境变量。
	也保存当前版本号。只是不下载。
	也生成目录树，
.android,ios版文件下载器，
	保存当前版本号，向远端递交当前版本号得到更新的服务器列表。以及新的版本号
	下载完后即生成目录树
.虚拟文件系统
	WriteFile()	new/updates
	DeleteFile()
	ReadFile()
	1.android 下直接读取apk
	2.libzip
	
动作
网格
骨骼
材质
纹理
	普通纹理
	Normap
	Lightmap
	Sprite(2D&UI)
Shader


unity 在运行时的单元测试
	创建单元测试场景
		专门的单元测试版本。
unsafe代码在il2cpp模式下
flatbuffers读取结构数组的效率:两种模式下，真实平台上，与直接调用unity3d的assetbundle运行效率统计		
	mono2x:
	il2cpp:

ok.?文件的格式
	ok 文件头的写法、读法
	no 可升级的版本方案？
ok.先完善功能还是先写测试	先写测试


ok 逗逼引擎规则。	
	ok 材质名作为模型组中可更换的参数。MeshPart中，需要指明材质名。不包含在网格资源中。
		通用的 主纹理和主颜色参数设置
		更换主纹理 + 更换主颜色 + 更换材质（可动画）
	ok 场景文件中保存足够的信息。Transform,Material,Collider
	ok 资源文件只包含单一资源
	ok 实例材质和模版材质	
		特殊的参数修改，就成为了特殊材质。（换颜色，换纹理）倾向于 1，3
		更换shader 同上
	ok 输出网格时，如果原资源中包含多网格，输出后文件名使用 网格名@资源名.db3d 形式

ok.资源输出的单元测试
	ok.单元测试的资源怎么办？
		ok 方案 
			以.开头的资源目录
			以assetBundle方式工作。
			打包工具，读取打包列表
		no unity的打包是有比较的.
		
		
		
	ok 输出和存盘分开	得益于单元测试，这样更好测试。
	ok 骨骼输出测试用例
		输出结果中没有重复的骨骼。
		每个原骨骼都被输出了（按名称）
		每个被输出的骨骼都存在原骨骼。
			输出的骨骼都是不带renderer的。
			每个被输出的骨骼的父节点都是正确的
			每个骨骼的局部矩阵都是相应的。
	ok 网格输出测试用例
		顶点成分
			每个顶点成分都被输出了
			每个输出的顶点成分都存在着原成分
			每个成分的数量都与顶点数相等
			每个成分的数值都与原数据相等
		三角面列表
		submeshes:[SubMesh];
		joints:[string];
		bindposes:[Matrix16];
	ok 材质输出测试用例
		结果中的属性与源材质都相等。
		源材质的属性都被输出了。
			
	ok 动作输出测试用例
		
	ok 递归收集骨骼独立出工具类.
	ok 单元测试装载assetbundle功能单独出工具类
	
	
ok.资源读入功能
	纹理加入 offset 和 scale

ok.资源读入的单元测试
	预先写入文件，
		读入文件作为源数据
		生成的模型作为比较目标
ok.显示测试角色

ok.纹理，shader输出
	ok 纹理打包工具
	ok 从包中读取原始纹理数据
		不需要完全写成正确格式,只需要记录足够信息即可.
	
	ok 看运气,在Editor中运行其他平台时,rawData的正确性
		如果无运气,1是解assetBundle包 2是自己做纹理转换工具.
		
	ok 测试时还需要切换平台.
		测试分为平台相关和平台无关两部分.分开进行.
			平台相关测试只测试当前平台.要切换平台再进行测试.
		
ok.shader打包工具


streamingAssets目录本来就是不打包的.
	打开文件
	定位读
zip部分使用原生代码还是c#代码	
	
	

.资源文件读写测试
	ok 写入文件 读出文件 写入之前和读出之后做比较。
	todo:读不到应该要报错
		写入文件有可能失败?
.完善测试用例的数据，以覆盖所有的分支情况。	
.文件预处理的规则
	动画规范,wrapMode的配置.
	纹理的命名规则
	材质的shader对应规则,纹理的指定规则.
	
	
.所有与"Assets/ArtWork" ".root"	相关的路径都放到一个工具类.
	
	
.纹理，shader输出的单元测试
	windows平台
	android&ios
.加入粒子资源
.modelGroup机制
.虚拟文件系统
.资源管理和加载机制	
.角色查看器
.动态场景
	.地形	
	.组件信息
		transform
		renderer
		collider
		Camera
		Light
		Sound
		terrain
.界面	
	
	
.?逻辑数据直接客户端模块读取？	




1.资源输入预处理	要保证资源输入时被正确处理过.节省人工.
	多材质如何处理?
		一个renderer下的多材质
		子节点的多材质
	
2.批量转换资源
	模型组输出. 暂时先做一个不使用模型组配置的版本.
		不带@的输出网格资源
		带@的输出动作资源
		材质资源与网格资源存在一起
		
		ok 如何遍历material的所有属性
		ok 遍历文件
		如何输出/还原动画文件
		如何还原texture的类型


	这样做是和shader的算法相关。实际上为了shader算法，是已经改变了normalmap的内容。
	it seems when you import a normal map to unity, it intenally has the setup of RGB = y normal, A = x normal.
			
	loadedTexture = www.texture;
	normalTexture = new Texture2D(loadedTexture.width,loadedTexture.height,TextureFormat.ARGB32,false);
	Color theColour = new Color();
	for (int x=0; x<loadedTexture.width; x++){
	for (int y=0; y<loadedTexture.height; y++){
	   theColour.r = loadedTexture.GetPixel(x,y).g;
	   theColour.g = theColour.r;
	   theColour.b = theColour.r;
	   theColour.a = loadedTexture.GetPixel(x,y).r;
	   normalTexture.SetPixel(x,y, theColour);
	}
	}
	normalTexture.Apply();

	private Texture2D NormalMap(Texture2D source) {
         Texture2D normalTexture = new Texture2D(source.width, source.height, TextureFormat.ARGB32, true);
         Color theColour = new Color();
         for (int x = 0; x < source.width; x++)
         {
             for (int y = 0; y < source.height; y++)
             {
                 theColour.r = 0;
                 theColour.g = source.GetPixel(x, y).g;
                 theColour.b = 0;
                 theColour.a = source.GetPixel(x, y).r;
                 normalTexture.SetPixel(x, y, theColour);
             }
         }
         normalTexture.Apply();
         return normalTexture;
     }
		
	按照模型组配置输出
	场景输出	


纹理规范
	法线贴图后缀 _NRM
	高光贴图后缀 _SPC

	max中材质名应该与shader相对应?

角色规范
	动作命名@是为了不重复生成纹理.
	动作 wrapMode 应该在 max 中指定.


Doubility3D_Tools
Doubility3D_Engine
Doubility3D_Client


如何在导入时直接把shader指定成想要的。
StreamingAssets 只保存一个zip包作为运行时数据。
	先在.data中读取，如果没有则在
	问题变成如何直读zip包。（最差情况，也只在第一次运行时需要一次拷贝）
	如何产生相应平台
		纹理。
			可利用assetBundle打包
			Texture2D.GetRawTextureData
			Texture2D.LoadRawTextureData
		Shader
			这是唯一要做成assetBundle的部分。	

在U3D和客户端逻辑之间传送消息 以flatbuffer为手段
	U->N	
		所有逻辑物体的 Transform
		动画播放完毕事件
		非界面操作
		界面操作
	N->U
		装载地图
		创建指定参数的逻辑物体
		向GameObject发出指令
		刷新界面数据
		
	服务器<->逻辑客户端<->图形层	
	
	传输效率值得担心！
		

逻辑客户端使用 golang.
	go 1.5可以编译为桌面程序的动态链接库
	go mobile 可以编译为 android ios 的库
		编译ios库需要在 mac 机器上进行。
		
0.资源准备
	角色网格+动作
	角色特效
	场景地形+植被、摆设
	场景网格+动画+特效
1.美术工具
	资源输出
		场景
			场景物体记录细化
				因为场景非常大，原方式已经不适用。
		网格 对材质和shader的引用
		材质 对纹理的引用
		纹理
		动画
		shader
		界面
		音效
		音乐
2.图形层
	资源管理器
	角色显示
	场景显示
	自定义资源包
	游戏视觉协议 flatbuffer C#
	2D模拟图形层
3.逻辑客户端
	与图形层协议 flatbuffer Go
	编译golang模块
	