动作
网格
骨骼
材质
纹理
	普通纹理
	Normap
	Lightmap
	Sprite(2D&UI)
Shader


ok.?文件的格式
	ok 文件头的写法、读法
	no 可升级的版本方案？
ok.先完善功能还是先写测试	先写测试


ok 逗逼引擎规则。	
	ok 材质名作为模型组中可更换的参数。MeshPart中，需要指明材质名。不包含在网格资源中。
		通用的 主纹理和主颜色参数设置
		更换主纹理 + 更换主颜色 + 更换材质（可动画）
	ok 场景文件中保存足够的信息。Transform,Material,Collider
	ok 资源文件只包含单一资源
	ok 实例材质和模版材质	
		特殊的参数修改，就成为了特殊材质。（换颜色，换纹理）倾向于 1，3
		更换shader 同上
	ok 输出网格时，如果原资源中包含多网格，输出后文件名使用 网格名@资源名.db3d 形式

.资源输出的单元测试
	单元测试的资源怎么办？
		ok 方案 
			以.开头的资源目录
			以assetBundle方式工作。
			打包工具，读取打包列表
			
		
		
	ok 输出和存盘分开	得益于单元测试，这样更好测试。
	骨骼输出
		输出的骨骼都是不带renderer的。
		输出结果中没有重复的骨骼。
		每个原骨骼都被输出了（按名称）
		每个被输出的骨骼都存在原骨骼。
		每个被输出的骨骼的父节点都是正确的
		每个骨骼的世界矩阵都是相应的。
	网格输出
		顶点成分
			每个顶点成分都被输出了
			每个输出的顶点成分都存在着原成分
			每个成分的数量都与顶点数相等
			每个成分的数值都与原数据相等
		三角面列表
		
	
.资源读入的单元测试

.纹理，shader输出
	纹理打包工具
	从包中读取原始纹理数据
	shader打包工具
.纹理，shader输出的单元测试
	windows平台
	android&ios
	

.地形	
.组件信息
	transform
	renderer
	collider
	Camera
	Light
	Sound
	terrain
	
	
	
.?逻辑数据直接客户端模块读取？	




1.资源输入预处理	要保证资源输入时被正确处理过.节省人工.
	多材质如何处理?
		一个renderer下的多材质
		子节点的多材质
	
2.批量转换资源
	模型组输出. 暂时先做一个不使用模型组配置的版本.
		不带@的输出网格资源
		带@的输出动作资源
		材质资源与网格资源存在一起
		
		ok 如何遍历material的所有属性
		ok 遍历文件
		如何输出/还原动画文件
		如何还原texture的类型


	这样做是和shader的算法相关。实际上为了shader算法，是已经改变了normalmap的内容。
	it seems when you import a normal map to unity, it intenally has the setup of RGB = y normal, A = x normal.
			
	loadedTexture = www.texture;
	normalTexture = new Texture2D(loadedTexture.width,loadedTexture.height,TextureFormat.ARGB32,false);
	Color theColour = new Color();
	for (int x=0; x<loadedTexture.width; x++){
	for (int y=0; y<loadedTexture.height; y++){
	   theColour.r = loadedTexture.GetPixel(x,y).g;
	   theColour.g = theColour.r;
	   theColour.b = theColour.r;
	   theColour.a = loadedTexture.GetPixel(x,y).r;
	   normalTexture.SetPixel(x,y, theColour);
	}
	}
	normalTexture.Apply();

	private Texture2D NormalMap(Texture2D source) {
         Texture2D normalTexture = new Texture2D(source.width, source.height, TextureFormat.ARGB32, true);
         Color theColour = new Color();
         for (int x = 0; x < source.width; x++)
         {
             for (int y = 0; y < source.height; y++)
             {
                 theColour.r = 0;
                 theColour.g = source.GetPixel(x, y).g;
                 theColour.b = 0;
                 theColour.a = source.GetPixel(x, y).r;
                 normalTexture.SetPixel(x, y, theColour);
             }
         }
         normalTexture.Apply();
         return normalTexture;
     }
		
	按照模型组配置输出
	场景输出	


纹理规范
	法线贴图后缀 _NRM
	高光贴图后缀 _SPC

	max中材质名应该与shader相对应?

角色规范
	动作命名@是为了不重复生成纹理.
	动作 wrapMode 应该在 max 中指定.


Doubility3D_Tools
Doubility3D_Engine
Doubility3D_Client


如何在导入时直接把shader指定成想要的。
StreamingAssets 只保存一个zip包作为运行时数据。
	先在.data中读取，如果没有则在
	问题变成如何直读zip包。（最差情况，也只在第一次运行时需要一次拷贝）
	如何产生相应平台
		纹理。
			可利用assetBundle打包
			Texture2D.GetRawTextureData
			Texture2D.LoadRawTextureData
		Shader
			这是唯一要做成assetBundle的部分。	

在U3D和客户端逻辑之间传送消息 以flatbuffer为手段
	U->N	
		所有逻辑物体的 Transform
		动画播放完毕事件
		非界面操作
		界面操作
	N->U
		装载地图
		创建指定参数的逻辑物体
		向GameObject发出指令
		刷新界面数据
		
	服务器<->逻辑客户端<->图形层	
	
	传输效率值得担心！
		

逻辑客户端使用 golang.
	go 1.5可以编译为桌面程序的动态链接库
	go mobile 可以编译为 android ios 的库
		编译ios库需要在 mac 机器上进行。
		
0.资源准备
	角色网格+动作
	角色特效
	场景地形+植被、摆设
	场景网格+动画+特效
1.美术工具
	资源输出
		场景
			场景物体记录细化
				因为场景非常大，原方式已经不适用。
		网格 对材质和shader的引用
		材质 对纹理的引用
		纹理
		动画
		shader
		界面
		音效
		音乐
2.图形层
	资源管理器
	角色显示
	场景显示
	自定义资源包
	游戏视觉协议 flatbuffer C#
	2D模拟图形层
3.逻辑客户端
	与图形层协议 flatbuffer Go
	编译golang模块
	